#include "../include/inhibitor.h"

/*IPC id variables*/
int shm_id, sem_id, msgq_id;

/*shared memory's struct*/
shared_stats *shm_pointer;

/*configuration's struct*/
configuration config;

/*struct to specify the interval of time to wait (nanosleep)*/
struct timespec req;

/*struct of a set of signal used to save the old mask when we change it*/
sigset_t old_mask;

int main(int argc, char *argv[])
{
    if (argc < 4)
    {
        perror("Missing agruments to execve call of the inhibitor");
        exit(EXIT_FAILURE);
    }

    /*setting the handler for the main signal we want to use*/
    set_handler(SIGTSTP, sig_handler, 0);
    set_handler(SIGTERM, sig_handler, 0);

    /*fetching the id of the ipc structures*/
    shm_id = atoi(argv[1]);
    sem_id = atoi(argv[2]);
    msgq_id = atoi(argv[3]);

    /*fetching the configuration's values and setting config*/
    if (ini_parse("./config/config.ini", handler, &config) < 0)
    {
        perror("Can't load 'config.ini'\n");
        exit(EXIT_FAILURE);
    }

    /*setting the number of nanosecond with the value taken from the configuration struct*/
    req.tv_nsec = config.inhibitor_step;

    /*attaching the shard mameory and checking for some error*/
    shm_pointer = (shared_stats *)(shmat(shm_id, NULL, 0));
    if (shm_pointer == (void *)-1)
    {
        perror("an error occurred attaching the shared memory");
        raise(SIGINT); // Clean exit on error
    }

    /*writing onto the logfile*/
    log_message("Inhibitor Process was created...", getpid(), sem_id);

    /*unblock SIGTSTP signal, blocked by the parent process previously*/
    unblock_signals(1, SIGTSTP);

    while (1)
    {
        /*checking the inhibitor status from the shared memory*/
        if (shm_pointer->inhibitor_mode == 0)
        {
            /*suspend the inhibitor until it reaches a signal*/
            printf("Inhibitor is suspended, waiting...\n");
            pause();
            continue;
        }
        /*protecting the inhibitor cycle from SIGTSTP signal*/
        old_mask = block_signals(1, SIGTSTP);

        /*Seeking the pid of an atom from the msg queue when the semaphore it's free*/
        pid_t atom_pid;
        semaphore_operation(sem_id, MSGQ_SEM, -1);
        do
        {
            atom_pid = receive_msg(msgq_id);
        } while (atom_pid == -1);
        semaphore_operation(sem_id, MSGQ_SEM, 1);

        /*wrinting the action into the logfile*/
        char message[50];
        sprintf(message, "Inhibitor Process inhibited an atom with pid: %i", atom_pid);
        log_message(message, getpid(), sem_id);

        /*Send splitting command to the atom found*/
        kill(atom_pid, SIGUSR2);

        /*waiting INHIBITOR_STEP seconds*/
        nanosleep_custom(&req);
        reset_signals(old_mask); /*end of the critical section*/
    }
}

/*signal handler of the process*/
void sig_handler(int signum)
{
    switch (signum)
    {
    /*singal generated by pressing ctrl+z on the keyboard*/
    case SIGTSTP:
        old_mask = block_signals(1, SIGTERM);

        shm_pointer->inhibitor_mode = !shm_pointer->inhibitor_mode; /*Alternate the inhibitor status*/
        if (shm_pointer->inhibitor_mode == 0)
        {
            write(1, "INHIBITOR SUSPENDED.\n", 22);
        }
        else
        {
            write(1, "INHIBITOR RESUMED.\n", 20);
        }

        reset_signals(old_mask);
        break;
    case SIGTERM:
        block_signals(1, SIGTSTP);
        shmdt(shm_pointer); /*deattach the shared memory*/
        exit(1);
        break;
    }
}